# Theoretical Technical Report on Heracles V1 and V2

## Table of Contents

- [Theoretical Technical Report on Heracles V1 and V2](#theoretical-technical-report-on-heracles-v1-and-v2)
  - [Table of Contents](#table-of-contents)
  - [Introduction](#introduction)
  - [System Architecture](#system-architecture)
  - [Hardware Components and Specifications](#hardware-components-and-specifications)
    - [Actuation System](#actuation-system)
    - [Motor Distribution](#motor-distribution)
    - [Component Costs (October 2025)](#component-costs-october-2025)
    - [Fault Tolerance](#fault-tolerance)
  - [4. Dataset Description](#4-dataset-description)
  - [Software and Control Systems](#software-and-control-systems)
    - [Reinforcement Learning Framework](#reinforcement-learning-framework)
    - [Simulation Environments](#simulation-environments)
    - [Micro-Operation Integration](#micro-operation-integration)
  - [Integration with Advanced Features](#integration-with-advanced-features)
  - [Version-Specific Details](#version-specific-details)
    - [V1](#v1)
    - [V2](#v2)
    - [V3](#v3)
    - [V4](#v4)
  - [8. Implementation Considerations](#8-implementation-considerations)
  - [Conclusion and Future Work](#conclusion-and-future-work)
  - [Document Data](#document-data)


## Introduction

The Heracles system, developed by Carson Wu, serves as a theoretical humanoid robotics platform focused on advancing motion control, precise manipulation, and adaptive locomotion within simulated environments. This platform incorporates elements from Project Hercules, the Application of Micro-Operation in Robot Motion Control, and the Dance Learning and Creation System to combine actuation mechanisms, reinforcement learning-based control, and fault-tolerant pose estimation for achieving interactions resembling human capabilities. The system addresses applications including dance instruction, detailed object handling, and responsive movement adjustment, presented across four versions: V1 with 46 motors, V2 with 152 motors featuring a shrimp-shell-like waist, V3 with 141 motors extending shrimp-shell joints to all articulations along with a 360-degree waist turntable, and V4 with 71 motors optimizing the tendon-spring joint configuration.

Given the cessation of physical assembly and testing as of October 2025, the Heracles system prioritizes theoretical design principles and conceptual integrations, with potential validations through simulation tools such as Gazebo, MuJoCo, or ROS. This report provides a detailed examination of the system's architecture, components, operational mechanisms, software coordination, and version-specific characteristics, including features, advantages, disadvantages, defects, improvements, and future prospects.

## System Architecture

The Heracles system adopts a modular and hierarchical structure to facilitate scalable control and data processing for complex humanoid motions. The architecture includes:

- **Hardware Layer**: Consists of NEMA 17 stepper motors (model 57BYG250B, 1.2 N·m torque, 3A current), L298N drivers, spur gears for V1 and V2, tendon-driven mechanisms for V3 and V4, a central computing unit (Raspberry Pi 5 for V1 to V3, Arduino Nano for V4), and a power supply. V1 maintains a rigid structure, V2 introduces a five-segment waist for increased flexibility, V3 applies shrimp-shell segmentation to all joints with an added waist turntable, and V4 refines this with single-motor tendon-spring joints.
- **Software Layer**: A Python-based control framework that incorporates reinforcement learning algorithms, micro-operation decomposition for motion sequencing, and JSON-based APIs for inter-component communication. The software handles data from the S.O.F.I.A. dataset to train and simulate models.
- **Data Flow**: Inputs such as motor revolutions, angles, velocities, and tensions (for V3 and V4) from the S.O.F.I.A. dataset are processed by the reinforcement learning model, which outputs control signals transmitted via GPIO interfaces to the motors or tendon systems. Feedback mechanisms continuously adjust outputs, supported by fault-tolerant pose estimation to maintain operational consistency.
- **APIs**: Custom JSON protocols enable communication between the reinforcement learning model, motor drivers, and simulation environments, ensuring synchronized data exchange for real-time adjustments.

This architecture allows for independent component optimization, where each module processes specific tasks before integrating results. For instance, in operation, the software layer receives joint position data, computes required adjustments using reinforcement learning, and sends precise pulse signals to the hardware layer, achieving coordinated movement across all versions.

## Hardware Components and Specifications

### Actuation System

The actuation system in all versions relies on NEMA 17 stepper motors paired with L298N drivers. For V1 and V2, spur gears (8-tooth input, 20-tooth output) provide a gear ratio of 2.5, calculated as:

- Gear Ratio: \( \frac{N_{\text{Driven}}}{N_{\text{Driving}}} = \frac{20}{8} = 2.5 \)
- Amplified Torque: \( T_{\text{Amplified}} = 2.5 \times 1.2 = 3 \, \text{N·m} \)
- Force: \( F = \frac{T}{r} = \frac{3}{0.02} = 150 \, \text{N} \)
- Weight Equivalent: \( \text{KG} = \frac{F}{g} = \frac{150}{9.8} \approx 15.31 \, \text{kg} \)

Variables include torque \( T \) in N·m, gear radius \( r \) of 0.02 m, force \( F \) in N, weight equivalent \( \text{KG} \) in kg, and gravitational acceleration \( g \) of 9.8 m/s².

For V3, a tendon-driven system with 2 motors per shrimp-shell joint (5 segments, 2 degrees of freedom per segment: pitch and yaw) distributes torque via linkages, with per-segment values: \( T_i = \frac{3}{5} = 0.6 \, \text{N·m} \), \( F_i = 30 \, \text{N} \), \( \text{KG}_i \approx 3.06 \, \text{kg} \). The primary motor pulls tendons for forward motion, while the secondary provides antagonistic control for precision.

V4 refines this to a single-motor tendon-driven system with spring-loaded linkages per joint. The motor angle \( \theta_m \) maps to segment angles as \( \theta_i = k_i \cdot \theta_m \), with \( \sum k_i = 1 \) and uniform \( k_i = 0.2 \). Springs store energy for return motions, reducing backlash to approximately 0.015 rad.

In operation, the hardware receives software-generated pulse signals via GPIO, converting them into motor steps or tension adjustments. For V3 and V4, tendon tensions are modulated to achieve segment coordination, ensuring smooth joint movement in simulations.

### Motor Distribution

- **V1 (46 Motors)**: Neck (3 motors for XYZ axes), elbows (4 motors for 2 × XY axes), hips (4 motors), knees (4 motors), ankles (4 motors). No fingers or toes.
- **V2 (152 Motors)**: Neck (3 motors), elbows (4 motors), hips (4 motors), knees (4 motors), ankles (4 motors), fingers (56 motors: non-thumbs 48, thumbs 8), toes (60 motors), waist (15 motors for 5 segments × XYZ).
- **V3 (141 Motors)**: Neck (2 motors), elbows (4 motors), hips (4 motors), knees (4 motors), ankles (4 motors), fingers (56 motors), toes (60 motors), waist (11 motors: 5 segments × 2 motors + 1 turntable).
- **V4 (71 Motors)**: Neck (1 motor), elbows (2 motors), hips (2 motors), knees (2 motors), ankles (2 motors), fingers (28 motors), toes (30 motors), waist (6 motors: 5 segments × 1 motor + 1 turntable).

Each version's distribution aligns with increasing complexity, where software coordinates motor signals to synchronize joint actions.

### Component Costs (October 2025)

- **V1**: Motors $230, drivers $230, Raspberry Pi 5 $90, gears $64, battery $75. Total: $689.
- **V2**: Motors $760, drivers $760, Raspberry Pi 5 $90, gears $64, battery $75. Total: $1,749.
- **V3**: Motors $705, drivers $710, Raspberry Pi 5 $90, tendons/pulleys $100, battery $100. Total: $1,705.
- **V4**: Motors $71, drivers $72, Arduino Nano $20, tendons/springs $7, battery $30. Total: $170.

These estimates reflect bulk procurement for theoretical budgeting.

### Fault Tolerance

Fault-tolerance rates include head/neck at 90%, torso/waist at 85%, limbs at 80%, and extremities at 75%. Software compensates by prioritizing critical joints during control signal generation.

## 4. Dataset Description

The S.O.F.I.A. dataset records motion data such as thigh Y-axis revolutions, brake status, X-axis rotations, and RPM, organized in outdoor and indoor folders with .mp4 videos and JSON files. In operation, the software processes this data to train RL models, adapting to scenarios for improved simulation performance.

## Software and Control Systems

### Reinforcement Learning Framework

The framework follows a structured process:
1. Hardware setup with simulated GPIO.
2. Software installation of Python libraries like RPi.GPIO or Arduino IDE and PyTorch.
3. Control program translates RL actions into motor pulses or tensions.
4. Markov Decision Process defines state (angles, velocities, tensions), action (steps or adjustments), and reward \( R = w_1 (1 - |\theta_{\text{target}} - \theta_{\text{actual}}|) - w_2 I_{\text{motor}} + w_3 (1 - \text{oscillation}) \).
5. Training uses PPO in Gazebo or MuJoCo.
6. Feedback from simulated sensors adjusts behavior.
7. Real-time control issues commands.
8. Optimization tunes hyperparameters.

Software coordinates by receiving dataset inputs, computing optimal actions, and sending signals to hardware for execution.

### Simulation Environments

Gazebo provides physics-based validation with ROS integration, while MuJoCo offers faster computations. Software integrates these for testing motion sequences.

### Micro-Operation Integration

Motions are broken into discrete steps or adjustments, with software sequencing commands to achieve precise control.

## Integration with Advanced Features

Dance practice involves video analysis mapped to motor commands, micro-operations enable granular sequencing, and precision tracking monitors 100 points per body part. Software processes video data, decomposes motions, and adjusts controls accordingly.

## Version-Specific Details

### V1

**Features**: Rigid structure with 46 motors focused on basic joints (neck, elbows, hips, knees, ankles).
**Operational Mechanism**: Motors receive pulse signals via GPIO, amplifying torque through gears for joint movement. Software computes actions from RL and coordinates basic locomotion.
**Advantages**: Low cost and simplicity for initial simulations.
**Disadvantages**: Limited dexterity without fingers, toes, or flexible waist.
**Defects**: Reduced range of motion in complex tasks like manipulation.
**Improvements**: Adds foundational control for future versions.
**Future Prospects**: Expand to include extremity actuators for enhanced applications.

### V2

**Features**: 152 motors with shrimp-shell waist (5 segments) for flexibility.
**Operational Mechanism**: Motors drive segmented joints, with software handling increased DOFs through RL for coordinated motions like grasping.
**Advantages**: Improved dexterity for dance and manipulation.
**Disadvantages**: Higher cost and computational demands.
**Defects**: Potential latency in high-DOF control.
**Improvements**: Introduces segmented waist over V1's rigidity.
**Future Prospects**: Refine segmentation for all joints.

### V3

**Features**: 141 motors with shrimp-shell joints throughout and waist turntable.
**Operational Mechanism**: Tendon-driven with 2 motors per joint; software adjusts tensions for segment coordination, enabling 360-degree rotation.
**Advantages**: Balanced cost and enhanced maneuverability.
**Disadvantages**: Complexity in tendon management.
**Defects**: Possible backlash in antagonistic control.
**Improvements**: Extends segmentation from V2, adds turntable.
**Future Prospects**: Optimize to single-motor designs.

### V4

**Features**: 71 motors with single-motor tendon-spring joints.
**Operational Mechanism**: Single motor pulls tendons, springs provide return; software optimizes dynamic tensions for precision.
**Advantages**: Significant cost reduction with maintained functionality.
**Disadvantages**: Slightly higher backlash from springs.
**Defects**: Reduced precision in ultra-fine tasks.
**Improvements**: Simplifies V3's dual-motor setup.
**Future Prospects**: Integrate advanced materials for further efficiency.

## 8. Implementation Considerations

Backend uses Python and PyTorch, scalable for V1 but requiring GPUs for V4. Limitations include latency in complex versions; ethical aspects focus on simulated data security.

## Conclusion and Future Work

The Heracles system provides a progressive framework from V1's basics to V4's optimization. Future efforts may explore hybrid actuations and expanded datasets for broader simulations.

## Document Data

- Author: Carson Wu
- Document Identification Code: 20251007_01
- The development timeline: 2016 - Present
